/**
 * ATS Scoring Engine (src/utils/atsScoring.js)
 * Fully documented heuristic algorithm to score resume vs job description.
 * See header comments for API and structures.
 */

const DEFAULT_WEIGHTS = Object.freeze({
  keywords: 0.38,
  sections: 0.14,
  formatting: 0.08,
  experience: 0.16,
  education: 0.08,
  skills: 0.10,
  recency: 0.06,
});
const DEFAULT_KEYWORD_EXTRACTION = Object.freeze({ minLen: 2, maxLen: 32, maxPhrases: 50, includeBigrams: true, includeTrigrams: true });
const DEFAULT_NORMALIZATION = Object.freeze({ clampMin: 0, clampMax: 100 });
const REQUIRED_SECTIONS = Object.freeze(['summary','experience','work experience','professional experience','education','skills']);
const OPTIONAL_SECTIONS = Object.freeze(['projects','certifications','licenses','awards','honors','publications']);
const DEGREE_KEYWORDS = Object.freeze(['bachelor','bachelors','b.sc','ba','bs','b.s','undergraduate','master','masters','m.sc','ms','m.s','ma','graduate','phd','ph.d','doctoral','associate']);

function normalize(text){return (text||'').replace(/\u00A0/g,' ').replace(/[\r\t]+/g,' ').replace(/\s+\n/g,'\n').replace(/\n{3,}/g,'\n\n').replace(/\s{2,}/g,' ').trim()}
function toLines(t){return normalize(t).split(/\n+/g)}
function toTokens(t){return normalize(t).toLowerCase().replace(/[^a-z0-9+.#\-\s]/g,' ').split(/\s+/g).filter(Boolean)}
function uniq(a){return Array.from(new Set(a))}
function clamp(v,min,max){return Math.max(min,Math.min(max,v))}
function nowIso(){try{return new Date().toISOString()}catch{return ''}}
function stem(token){if(token.length<=3) return token;return token.replace(/(ing|ed|ly|es|s)$/i,'').replace(/(ization|isation)$/i,'ize').replace(/(ment|ness)$/i,'').replace(/(ers|er)$/i,'er')}
function countYears(text){const years=[];const re=/(20\d{2}|19\d{2})/g;let m;while((m=re.exec(text))) years.push(parseInt(m[1],10));if(years.length<2) return {span:0,recentYear:Math.max(...years,0)};const minY=Math.min(...years);const maxY=Math.max(...years);return {span:Math.max(0,maxY-minY),recentYear:maxY}}
function detectSections(lines){const sections={};for(let i=0;i<lines.length;i++){const l=lines[i].trim().toLowerCase();const clean=l.replace(/[^a-z\s]/g,'');if(!clean) continue;[...REQUIRED_SECTIONS,...OPTIONAL_SECTIONS].forEach(k=>{if(clean.includes(k)) sections[k]=i})}return sections}

function extractKeywords(text, options){const cfg={...DEFAULT_KEYWORD_EXTRACTION,...(options||{})};const tokens=toTokens(text).filter(t=>t.length>=cfg.minLen&&t.length<=cfg.maxLen);const freq=new Map();for(const t of tokens) freq.set(t,(freq.get(t)||0)+1);const candidates=[];for(const [t,c] of freq) candidates.push({phrase:t,score:c});const raw=normalize(text).toLowerCase().replace(/[^a-z0-9+.#\-\s]/g,' ');const words=raw.split(/\s+/g).filter(Boolean);if(cfg.includeBigrams){for(let i=0;i<words.length-1;i++){const p=`${words[i]} ${words[i+1]}`;if(p.length>=cfg.minLen&&p.length<=48) candidates.push({phrase:p,score:1})}}if(cfg.includeTrigrams){for(let i=0;i<words.length-2;i++){const p=`${words[i]} ${words[i+1]} ${words[i+2]}`;if(p.length>=cfg.minLen&&p.length<=64) candidates.push({phrase:p,score:1})}}const merged=new Map();for(const c of candidates){const key=c.phrase.trim();if(!key) continue;merged.set(key,(merged.get(key)||0)+c.score)}const ranked=Array.from(merged.entries()).map(([phrase,score])=>({phrase,score})).sort((a,b)=>b.score-a.score).filter(k=>k.phrase.length<=48);return ranked.slice(0,cfg.maxPhrases).map(k=>k.phrase)}
function classifyKeywords(jobText){const lines=toLines(jobText.toLowerCase());const required=new Set();const optional=new Set();const reqMarkers=[/\brequired\b/,/\bmust\b/,/\bminimum\b/,/\bneed(ed)?\b/,/\bresponsibilities\b/];const optMarkers=[/\bnice to have\b/,/\bpreferred\b/,/\bplus\b/,/\bbonus\b/,/\boptional\b/];for(const line of lines){const kws=extractKeywords(line,{maxPhrases:8,includeTrigrams:false});const isReq=reqMarkers.some(r=>r.test(line));const isOpt=optMarkers.some(r=>r.test(line));for(const k of kws){if(isReq) required.add(k); else if(isOpt) optional.add(k)}}if(required.size===0){extractKeywords(jobText,{maxPhrases:20}).forEach(k=>required.add(k))}const trivial=new Set(['and','or','with','the','a','an','in','to','of','for']);const req=Array.from(required).filter(k=>!trivial.has(k));const opt=Array.from(optional).filter(k=>!trivial.has(k));return {required:uniq(req),optional:uniq(opt)}}
function scoreKeywordCoverage(resumeText, jobText){const {required,optional}=classifyKeywords(jobText);const resumeTokens=toTokens(resumeText);const resumeStems=new Set(resumeTokens.map(stem));const resumeTextLc=normalize(resumeText).toLowerCase();const found=[];const missing=[];const partial=[];const inResume=(phrase)=>{const p=phrase.toLowerCase();if(resumeTextLc.includes(p)) return 'exact';const parts=p.split(' ');if(parts.length===1){const s=stem(parts[0]);if(resumeStems.has(s)) return 'stem'}return false};for(const k of required){const m=inResume(k);if(m==='exact') found.push(k); else if(m==='stem') partial.push(k); else missing.push(k)}for(const k of optional){const m=inResume(k);if(m) found.push(k)}const requiredCoverage=required.length? (found.filter(k=>required.includes(k)).length + 0.5*partial.length)/required.length : 0;const optionalCoverage=optional.length? found.filter(k=>optional.includes(k)).length/optional.length : 0;const freq=(found.length+0.5*partial.length)/Math.max(50,resumeTokens.length);const density=clamp(freq*5,0,1);const score=clamp(0.65*requiredCoverage+0.25*optionalCoverage+0.10*density,0,1);return {score,coverage:{required,optional,found:uniq(found),missing:uniq(missing),partial:uniq(partial)}}}

function scoreSections(resumeLines){const sections=detectSections(resumeLines);const text=resumeLines.join('\n').toLowerCase();const hasReq=REQUIRED_SECTIONS.map(s=>Object.keys(sections).some(k=>k.includes(s)));const reqCoverage=hasReq.filter(Boolean).length/REQUIRED_SECTIONS.length;const hasOpt=OPTIONAL_SECTIONS.map(s=>Object.keys(sections).some(k=>k.includes(s)));const optCoverage=hasOpt.filter(Boolean).length/OPTIONAL_SECTIONS.length;const bullets=(text.match(/[\u2022\-â€¢]/g)||[]).length;const bulletScore=clamp(bullets/15,0,1);const score=clamp(0.7*reqCoverage+0.2*optCoverage+0.1*bulletScore,0,1);return {score,reqCoverage,optCoverage,bulletScore}}
function scoreExperience(resumeText, jobText){const {span,recentYear}=countYears(resumeText);const jd=normalize(jobText).toLowerCase();let desired=0;if(/\b(intern|junior|entry)\b/.test(jd)) desired=1; else if(/\b(mid|intermediate)\b/.test(jd)) desired=2; else if(/\b(senior|lead|principal|staff)\b/.test(jd)) desired=3;let yearsReq=0;const ym=jd.match(/(\d+)\+?\s*(?:years|yrs)/);if(ym) yearsReq=parseInt(ym[1],10)||0;const spanScore=clamp(span/Math.max(1,yearsReq||8),0,1);const resLc=normalize(resumeText).toLowerCase();let resSen=0;if(/(intern|junior|entry)/.test(resLc)) resSen=1; else if(/(mid|intermediate)/.test(resLc)) resSen=2; else if(/(senior|lead|principal|staff)/.test(resLc)) resSen=3;const seniorityMatch=desired===0?0.7:(1-Math.min(1,Math.abs(desired-resSen)/3));const currentYear=(new Date()).getFullYear? (new Date()).getFullYear():2025;const yearsSince= currentYear - (recentYear||currentYear);const recencyScore=clamp(1 - yearsSince/6, 0, 1);return {span,yearsReq,spanScore,seniorityMatch,recencyScore}}
function scoreEducation(resumeText, jobText){const resLc=normalize(resumeText).toLowerCase();const jd=normalize(jobText).toLowerCase();const hasDegree=DEGREE_KEYWORDS.some(k=>resLc.includes(k));const jdMentions=DEGREE_KEYWORDS.some(k=>jd.includes(k));let levelMatch=0;if(jdMentions&&hasDegree) levelMatch=1; else if(!jdMentions&&hasDegree) levelMatch=0.7; else if(jdMentions&&!hasDegree) levelMatch=0.2; const certifications=(resLc.match(/certified|certificate|certification|license|licensed|aws certified|azure|gcp|pmp|scrum|csm|cka|rhce|cisco|ccna|ccnp/g)||[]).length;const certScore=clamp(certifications/3,0,1);const score=clamp(0.75*levelMatch+0.25*certScore,0,1);return {score,levelMatch,certScore,hasDegree,certifications}}
function scoreFormatting(resumeText){const txt=normalize(resumeText);const lines=toLines(resumeText);const avgLen=lines.length? (lines.join(' ').length/lines.length):0;const hasContact=/@|linkedin\.com|github\.com|portfolio|phone|\b\d{3}[)\-\.\s]?\d{3}/i.test(txt);const noImages=true;const fancyFonts=false;const fileLength=txt.length;const lengthScore=clamp( (fileLength>=800?1:fileLength/800) * (fileLength<=8000?1:8000/fileLength), 0,1);const lineScore=clamp( avgLen>=40&&avgLen<=180?1:0.5, 0,1);const contactScore=hasContact?1:0.4;const score=clamp(0.5*lengthScore+0.2*lineScore+0.3*contactScore,0,1);return {score,lengthScore,lineScore,contactScore,noImages,fancyFonts}}
function scoreSkills(resumeText, jobText){const jdKws=extractKeywords(jobText,{maxPhrases:30});const resTxt=normalize(resumeText).toLowerCase();let matched=0;let synonyms=0;for(const k of jdKws){if(resTxt.includes(k.toLowerCase())) matched++; else {const parts=k.split(' '); if(parts.length===1){const s=stem(parts[0]); if(resTxt.split(/\W+/).some(t=>stem(t)===s)) {synonyms++;}}}}const base=jdKws.length? (matched + 0.5*synonyms)/jdKws.length : 0;return {score:clamp(base,0,1), matched, synonyms, total: jdKws.length}}

function aggregateScores(resumeText, jobText, options){const weights={...DEFAULT_WEIGHTS,...((options&&options.weights)||{})};const kw=scoreKeywordCoverage(resumeText, jobText);const lines=toLines(resumeText);const sec=scoreSections(lines);const exp=scoreExperience(resumeText, jobText);const edu=scoreEducation(resumeText, jobText);const fmt=scoreFormatting(resumeText);const skl=scoreSkills(resumeText, jobText);const rec=exp.recencyScore;const raw = (weights.keywords*kw.score + weights.sections*sec.score + weights.formatting*fmt.score + weights.experience*(0.6*exp.spanScore+0.4*exp.seniorityMatch) + weights.education*edu.score + weights.skills*skl.score + weights.recency*rec);return {raw, parts:{kw,sec,fmt,exp,edu,skl,rec}}}

function buildInsights(resumeText, jobText, parts){const tips=[];const {kw,sec,exp,edu,fmt,skl}=parts;const missingReq=kw.coverage.missing.slice(0,10);if(missingReq.length) tips.push(`Add missing required keywords: ${missingReq.join(', ')}`);if(kw.coverage.partial.length) tips.push(`Clarify partial matches with explicit terms: ${kw.coverage.partial.slice(0,10).join(', ')}`);if(sec.reqCoverage<1) tips.push('Ensure standard sections: Summary, Experience, Education, Skills');if(sec.optCoverage<0.5) tips.push('Consider adding Projects, Certifications, or Awards');if(fmt.contactScore<1) tips.push('Include clear contact details (email, LinkedIn, phone)');if(exp.spanScore<0.6) tips.push('Quantify total years of relevant experience');if(exp.seniorityMatch<0.8) tips.push('Align title/seniority wording with the job description');if(parts.rec<0.7) tips.push('Highlight recent, relevant work (last 2-3 years)');if(!edu.hasDegree) tips.push('If applicable, add education details and relevant certifications');if(skl.score<0.6) tips.push('Expand skills section with role-specific tools and technologies');return uniq(tips)}

function resolveOptions(options){const normalization={...DEFAULT_NORMALIZATION,...((options&&options.normalization)||{})};const keywordExtraction={...DEFAULT_KEYWORD_EXTRACTION,...((options&&options.keywordExtraction)||{})};const weights={...DEFAULT_WEIGHTS,...((options&&options.weights)||{})};return {normalization,keywordExtraction,weights,locale:(options&&options.locale)||'en'}}

export function scoreResume(resumeText, jobText, options){const opt=resolveOptions(options||{});const resTxt=normalize(resumeText||'');const jobTxt=normalize(jobText||'');const {raw,parts}=aggregateScores(resTxt, jobTxt, opt);const score=clamp(Math.round(raw*100), opt.normalization.clampMin, opt.normalization.clampMax);const breakdown={keywords:Math.round(parts.kw.score*100),sections:Math.round(parts.sec.score*100),formatting:Math.round(parts.fmt.score*100),experience:Math.round((0.6*parts.exp.spanScore+0.4*parts.exp.seniorityMatch)*100),education:Math.round(parts.edu.score*100),skills:Math.round(parts.skl.score*100),recency:Math.round(parts.rec*100)};const insights=buildInsights(resTxt, jobTxt, parts);return {score,breakdown,keywordCoverage:parts.kw.coverage,insights,meta:{tokensResume:toTokens(resTxt).length,tokensJob:toTokens(jobTxt).length,extractedKeywords:extractKeywords(jobTxt,{maxPhrases:30}),timestamp:nowIso(),options:opt}}}

export default { scoreResume };
